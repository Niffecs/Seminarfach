\chapter{Kryptografische Netzwerkprotokolle}

Kryptografie ist nicht nur in der Verschlüsselung von Daten und Dateien zu finden. Viele verschiedene Netzwerkprotokolle setzen schon heute auf Kryptologie. Es wäre fahrlässig, die privaten Daten unverschlüsselt durch das globale Netz zu senden. Sollte der Sender (im folgenden Alice) dem Empfänger (im folgenden Bob) eine Mitteilung senden, so ist ein strenger Ablaufplan einzuhalten, an welchen sich alle Beteiligten halten müssen. Sollte eine Partei gegen diesen verstoßen, kann eine korrekte Chiffrierung, eine erfolgreiche Übertragung oder eine Dechiffrierung nicht mehr gewährleistet werden. Dieser Plan ist unter den Namen Kommunikationsprotokoll oder kurz Protokoll bekannt. Die grundlegende Aufgabe eines oder mehrerer Protokolle ist der Datenaustausch von zwei Endgeräten. Vereinfacht kann man sich ein Protokoll wie folgt vorstellen. Der Sender und der Empfänger haben einen digital vorgefertigten Fragenkatalog. Der Empfänger kann nur auf eine Frage antworten, wenn er die Frage auch in seinem Katalog verzeichnet hat und er sie somit versteht. Eine solche Vorschrift benötigt auch bestimmte Informationen, um die ankommende Daten zu verarbeiten. Dieser Datenblock wird als Header bezeichnet. Bei Netzwerkprotokollen können dort zum Beispiel Daten wie (bei TCP) der Quellport und der Zielport direkt gespeichert werden. In Bezug auf Zweck und Aufgabe können und müssen diese variieren. Nach dem Header kommen die eigentlichen zu übermittelnden Daten, welche auch als Nutzlast oder als Payload bezeichnet werden. In der Regel steht der Header vor dem Payload. \\

Die kryptografischen Protokolle werden als Krypto-Protokolle bezeichnet, wovon ein Großteil die Verschlüsselungen selber sowie digitale Signaturen und kryptografische Hashfunktionen bilden. Ein kryptografisches Protokoll kann als Konzeptprotokoll oder Netzwerkprotokoll vorliegen. Jedem liegt, egal ob verschlüsselt oder nicht, das OSI-Modell zu Grunde. Den meisten und wichtigsten Protokollen wie TCP, IP, UDP fehlt jegliche Möglichkeit der Kryptografie. Zwar wurde an dieser Stelle nachgerüstet, dennoch wirkt dies eher wie gekünstelt. Gute Beispiele für Krypto-Protokolle sind SSL und TLS. TLS steht für Transport Layer Security, SSL dagegen für Secure Socket Layer. Anhand des Namens lässt sich erkennen, dass es auf der Schicht 4 arbeitet. Allgemein kann man sagen, das SSL die "vergessene" Kryptografie der TCP Familie nachholen will. Für UDP gibt es keine "Erweiterung", was allerdings auch nicht notwendig ist. Heutzutage (Stand 2015) ist SSL extrem weit verbreitet und aus unserem Leben eigentlich nicht mehr wegzudenken. Ironischer weise ist heutzutage SSLv3 immer noch bekannter als TLS.
SSL zieht oberhalb des TCP-Protokolls eine weitere Protokollschicht. Diese kann man sehr gut als Sicherungsschicht bezeichnen und heißt Record Layer.
Die Aufgabe dieser Schicht ist die Nutzung der kryptografischen Parameter und deren Authentifikation. TCP arbeitet auf der vierten Schicht des OSI-Modells, dem Transport Layer. \\

Da der Record Layer vor TCP sein muss, liegt diese virtuelle Schicht zwischen dem Session und dem Presentation Layer, folglich zwischen HTTP und TCP. Nach dem OSI-Modell alle Schichten die "höher" als die vierte Schicht liegen, zählt der Record Layer zu den anwendungsorientierten Schichten. SSL ist ähnlich wie TCP ein verbindungsorientiertes Protokoll und weist keinen verbindungslosen Teil wie UDP auf. Es legt sich nicht auf eine bestimmte Verschlüsselung fest und erlaubt mehrere symmetrische Verschlüsselungen, wobei allerdings nur Eine angewendet werden kann. Zurzeit ist es nicht möglich, mehrere Algorithmen in einem Bytestrom zu verwenden. Die aktuellen Ordnungen legen "nur" RC2, RC4, Triple-DES und AES fest Zum Erzeugen des Schlüssels ist eine Hashfunktion notwendig. Um den Hash zu erhalten, wird die auf HMAC basierende SHA-256 Spezifikation genutzt. Andere SHA Methoden sind erlaubt, aber nicht empfohlen. Für den Schlüsselaustausch wird RSA oder der Diffie-Hellman Algorithmus genutzt. Diese Algorithmen reichen für SSL vollkommen aus, eine richtige Wahl der Primzahlen bei RSA vorausgesetzt. SSL selber besteht aus zwei Teilschichten. Diese kann man sich wie bei UDP vorstellen. Die obere ist zum Verhandeln von Verfahren und Parametern da und für Fehlermeldungen, die untere hingegen beinhaltet das eigentliche Protokoll und übernimmt somit die Verschlüsselung.
SSL besteht aus fünf verschiedenen Teilprotokollen. Die fünfte Schicht arbeitet das Record Protokoll ab. Dies ist wie schon erwähnt, der untere Layer. Alle anderen vier Protokolle arbeiten auf der oberen Schicht und haben ähnliche Aufgaben in anderen Protokollen. Im Folgenden werde ich nach einigen allgemeinen Erläuterungen auf die verschiedenen Ebenen genauer eingehen und diese Schritt für Schritt erklären.\\
Der Record Layer (RL) stellt einen ankommen Bytestrom in $2^14 = 16384$ Bytes dar. Man bezeichnet diese als Records. Im Idealfall werden diese Blöcke noch komprimiert. Zur Authentifikation der einzelnen Blöcke wird ein Message Authentication Code (MAC) genutzt. Bei vielen Netzprotokollen muss eine Sequenznummer erzeugt werden, mit welcher man erkennen kann, ob die Pakete in der richtigen Reihenfolge ankommen. Hier sollte in der Verschlüsselung die Sequenznummer beachtet werden. Wichtig ist auch, dass der MAC den ersten Key nutzt. Da aber beim ersten Paket noch kein Key vorhanden ist, wird es ohne MAC und somit auch ohne Verschlüsslung übertragen. Der erste untere Layer (auf der oberen Schicht) ist das Handshake Protokoll. Es bildet das "Herzstück" des gesamten SSL Gerüstes. Grundlegend gesagt, findet hier der Schlüsselaustausch zwischen dem Server und dem Client statt. Dies funktioniert mit dem Zwei-Wege-Handshake. Der Client nimmt Kontakt zum Server auf. Dafür nutzt er die ClientHello Nachricht. Aus dieser werden für den Server wichtige Informationen (wie zum Beispiel die Versionsnummer) gefiltert.
Weiter sendet der Client alle ihm bekannten kryptografischen Verfahren ("Ciphersuites") und eine Sessionnummer ("Session-ID"). Diese Session-ID hat eine Lebenszeit und führt, sollte sie dem Server bekannt sein, zu einer Verkürzung des Handshakes.\\

Weiter sendet der Client eine Zufallszahl, die im double Bereich liegt (also zwischen $55.0*10^-324$ und $1,7*10^308$). Im Normalfall antwortet der Server mit einem Server „Hallo“ und übermittelt mit diesem ebenfalls ein Zertifikat. Über eine Zertifizierungsstelle kann der Client die Gültigkeit des Zertifikates überprüfen. Sollte dies erfolgreich geschehen sein, sendet der Client dem Server eine entsprechende Nachricht, dass er „fertig“ ist. Der Server antwortet daraufhin, ebenfalls mit „fertig“. Nun kann der eigentliche Datenaustausch beginnen. Im zweiten Unterprotokoll, dem ChangeCipherSpec Protokoll müssen alle vorherigen Blöcke, bis und einschließlich dem der ChangeCipherSpec verschlüsselt werden. Für eine einzelne Übertragung, heißt für eine gesamte Anfrage, darf nur ein bestimmter kryptografischerer Algorithmus genutzt werden. Das bedeutet, für jeden Durchlauf wird ein eigener Record benutzt. Grundlegend kann man sagen, dass diese Schicht als zweite Verschlüsselungsebene arbeitet. Auch in SSL (bzw. TLS) kann es durchaus zu Fehlern kommen. Das dritte Unterprotokoll, das Alert Protokoll, erkennt den Fehler und gibt diesen dem Nutzer aus. Alert-Nachrichten haben die Größe von 2 Byte. Der Erste gibt den Grad des Fehlers an und am Zweiten erkennt man diesen präziser. Einer Fehlermeldung wird eine Zahl zugeordnet. So lautet zum Beispiel für ein unbekanntes Zertifikat der Fehlercode 46. Eine genauere Beschreibung der Fehler findet man in DA99. Das letzte Unterprotokoll ist das Application Data Protokoll. An dieser Stelle ist zu sagen, dass SSL keine Daten, die vom Nutzer selber deffiniert wurden, überträgt. Es stellt „nur“ eine verschlüsselte Grundlage zwischen Client und Server dar. So hat fast jeder Schritt im Handshake einen eigenen Tag. welcher ähnlich dem Alert Protocoll durch eine ID repräsentiert wird. Um erfolgreich eine Nachricht auszugeben, werden folgende Informationen benötigt. Die Länge der Nachricht, der Nachrichtentyp, welcher von der ID repräsentiert wird und natürlich die Mitteilung selber. Alle Nachrichten können in einem SSL Record zusammengefasst werden. \\
Grundlegend beginnt ein Client einen Handshake mit der Client-„Hello“ Nachricht. Ausnahmen bestätigen die Regel, was bedeutet, dass in besonderen Fällen auch der Server einen Handshake beginnen kann. Die Grundaufgabe von SSL besteht darin, dem Nutzer zu signalisieren, dass er sich auf einem vertrauenswürdigen Server befindet. Besonders wichtig ist hierbei nicht nur die Verschlüsselung, sondern auch die Authentifikation des Servers. Dafür werden Zertifikate genutzt, welche von Prüfstellen ausgegeben werden. Diese nennt man Certificate Authorities oder kurz nur CA’s. Heutzutage gibt es eine große Anzahl von CA’s. Manchen kann man bedingungslos vertrauen, bei anderen sollte man schnell die Finger davonlassen. In diesen Zertifikaten sind alle wichtigen Informationen gespeichert. Darunter zählt unter anderem die Lebensdauer. Ein Zertifikat wird nicht für ewig ausgestellt.
Im Großen und Ganzen bildet SSL und TLS ein solides kryptografisches Netzwerkprotokoll. Es bietet eine sehr hohe Sicherheit. Selbst Bankgeschäfte werden unter zu Hilfenahme von RSA abgeschlossen.

\section{Ransomware am Beispiel Petya}
Kryptotrojaner sind Trojaner, welche den Zugriff auf eigene Dateien verhindern. Sie verschlüsseln bzw. sperren alle Daten auf dem Gerät. Die Daten werden dann nur durch Zahlung eines Lösegeldes herausgegeben. Daher stammt auch der Name Ransomeware. Strafrechtlich fällt solche Software unter die digitale Erpressung.\\

„Ransomeware ist einzigartig unter der Internet-Kriminalität, weil damit der Angriff erfolgreich ist, es erfordert das Opfer ein williger Komplize nach der Tat zu werden“ sagte James Scott. Dieses Zitat beschreibt die Lage sehr genau. Damit der Täter erfolgreich ist, muss das Opfer bereit sein, Geld zu zahlen, um so seine privaten Daten wiederzubekommen. Würde plötzlich niemand mehr bezahlen, würde schlagartig die Popularität von Krypto Trojanern zurückgehen. Für die bekanntesten Varianten gibt es zwar heute schon sehr gute Onlinehilfen, welche aber kaum in Anspruch genommen werden. \\

Ransomeware ist dabei nichts Neues. Laut dem Bundesamt für Sicherheit in der Informationstechnik geht die Historie der Maleware bereits auf das Jahr 1989 zurück. Der Trojaner zeigte dem Nutzer an, dass eine Lizenz abgelaufen ist und verschlüsselte daraufhin alle Dateien unter C:\ unabhängig davon, was sich darauf befand. Man konnte auf seine Daten erst wieder nach der Bezahlung von 165 US-Dollar, an eine Briefkastenfirma in Panama, zugreifen. Der Täter wurde sehr schnell gefasst, allerdings nie verurteilt, da er labil war. Viele Nutzer zahlen das geforderte Lösegeld, da der Leidensdruck der Opfer einfach zu hoch ist. Heutzutage wird es immer schwieriger, die Täter ausfindig zu machen, da man nur sehr schwer nachvollziehen kann, wer der eigentliche Absender ist. Auch das die Lösegeldzahlung in BitCoin bzw auf Postfächer in Panama gezahlt wird, ist nicht sehr hilfreich.\\

Die Bedrohungslage in Bezug auf Kryptotrojaner steigt seit Januar 2016 stark an. Das liegt an der Attraktivität des Geschäftsmodelles. Die Wahrscheinlichkeit, dass der Täter nicht verurteilt werden kann, ist leider aktuell sehr hoch. Laut BSI wurden im Februar 2016 10-mal so häufig infizierte Rechner bzw. Netzwerke gemeldet als noch im Oktober 2015. Diese Angabe bezieht sich nur auf Deutschland. Allerdings ist auch weltweit ein großer Anstieg von Infizierten Computern zu verzeichnen. Im Mai 2016 wurde durch die Softwarefirma Kaspersky die Ransomeware Petya „gefunden“.\\


Dass dieser Trojaner so bekannt wurde, liegt unter anderem an der sehr großen Schadenswelle, die er hinter sich herzog. Petya reicht es nicht, nur die Festplatte des Opfers zu verschlüsseln, es überschreibt auch den Master Boot Record. Auffällig daran ist auch, dass Petya im Vergleich zu dem älteren Locky, die Dateien nicht auf bestimmte Endungen (wie zum Beispiel*.docx, *.pdf, *.mp3 oder *.jpg) durchsucht, sondern gleich alles verschlüsselt. Oft findet man den Trojaner als „Bewerbung“. Daraus kann man auch erkennen, dass nicht der normale Bürger das Ziel ist, sondern die Unternehmen im eigentlichen Fokus stehen. Bei dieser Bewerbung handelt es sich um ein Zip-Archiv mit nur einer kleinen Datei. Die Wirkung entfaltet sich nicht beim Entpacken des Archives sondern erst beim Öffnen der sich darin befindenden Datei. Petya selber geht in zwei verschiedenen Stufen vor. Sollte die zweite Instanz noch nicht gearbeitet haben, ist es möglich, seine Daten zu retten. Wenn der Nutzer auf den das entpackte Programm klickt, geschieht auf dem Desktop erst mal nicht sehr viel. Der Nutzer soll ja auch von der ganzen Aktion nichts mitbekommen. Indes überschreibt der Trojaner den MBR und leitet diesen auf eine andere Datei um. So ist es dem Betriebssystem bei einem Neustart nicht mehr möglich, das OS zu laden. Ist dies geschafft, bringt Petya Windows zum Abstürzen. Beim Neustart erscheint dem Nutzer nicht der normale Windows Bildschirm, sondern ein Programm, welches vorgibt das System auf Fehler zu überprüfen. In Wahrheit werden erst hier die Daten verschlüsselt. Solange der Vorgang läuft und man den Computer vor dem erneuten booten schützt, kann man die privaten Daten leicht retten. Ist der „Counter“ jedoch auf 100\% gelaufen, ist dies kaum mehr möglich. Markant für das Petya in der ersten und in der zweiten Version ist ein weiß-rot blinkender Totenkopf. Nun erscheint nach jedem booten ein Bildschirm mit der Aufforderung, den Key zu kaufen. Dafür gibt Petya dem Opfer einen Link, der auf eine sehr unseriöse *.onion Seite verweist. Aktuell und laut verschiedenen Quellen liegt der Kostenpunkt für einen solchen Key bei 0.45 BTC. Bei einem aktuellen Wechselkurs von 1 BTC zu 2911 EUR kostet ein Key also um die 1310 EUR. Wie bereits erwähnt, sollte man schon vor dem eigentlichen Absturz beginnen, seine privaten Daten zu retten. Eine Lösung wäre, solange die Windowsfehlermeldung erscheint, in das Boot Menue zu gehen und den PC so einzustellen, dass er nicht von der Festplatte, sondern von einer CD/DVD bootet. Mit dieser Live CD ist es möglich, eine Eingabeaufforderung (CMD) mit Administratorenrechten zu starten. Durch den Befehl notepad kann man dann jenes Programm öffnen welches ermöglicht sich zu überzeugen, dass noch keine Daten auf der Festplatte verschlüsselt wurden. Mit folgendem cmd-Befehl kann man die „kaputten“ Bootsektoren reparieren.

\begin{center}
	\textbf{\texttt{X:\textbackslash Sources> bootrec /RebuildBcd}}
\end{center}

Dies dauert circa eins bis zwei Minuten. Der Befehl trägt das alte BcD wieder als Standartsystem ein, so dass der erste und auch größte Schritt bereits getan ist.\\

\begin{center}
	\textbf{\texttt{X:\textbackslash Sources>bootrec /fixMbr}}
\end{center}

Dieser Befehl schreibt den Masterbootrecord erneut an den Anfang der Festplatte. Sollte dies Fehlschlagen, kann mit \texttt{bootrec /scanos} manuell nach Mbr’s gesucht werden.



\begin{center}
	\textbf{\texttt{X:\textbackslash Sources>bootrec /fixboot}}
\end{center}

Der Befehl erstellt den Boot Manager neu und ist somit eine große Hilfe. Nach einem kompletten Kaltstart sollte der Computer wie gewohnt funktionieren und Windows ebenso starten. Die meisten Opfer nutzen bzw. realisieren diesen Zeitabschnitt erst viel zu spät und lassen somit die wertvolle Zeit für die Rettung ihrer Daten verstreichen. Genau darauf setzt Petya und hofft, dass das Opfer ein Lösegeld für seine privaten Daten bezahlt. Die erste Version wurde von dem User Leostone unter Zuhilfenahme genetischer Algorithmen entschlüsselt. Im Mai desselben Jahres wurde durch den Erpresser eine zweite Version des Kryptotrojaners veröffentlicht. Auch diese konnte unter Zuhilfenahme von Grafikkarten geknackt werden. Am 27. Juni 2017 erfolgte eine neue große Petya Angriffswelle. Auch hier war das Hauptziel große Firmen weltweit. Schönbohm (Präsident des BSI) ist der Meinung, dass es möglich gewesen sei, die neue Angriffswelle abzuwehren, da die ausgenutzte Schwachstelle schon lange bekannt war. Immer wenn eine Version geknackt wurde und somit Lösungsmöglichkeiten entstanden, dauerte es nicht lange, bis eine neue und somit auch bessere Version erschient. Das ist auch bei Petya der Fall. Neben Petya 1 und 2 gibt es noch eine grüne und eine goldene Version. Wie viele Versionen es von dem Trojaner inzwischen gibt, ist unbekannt. Ebenso ist noch nicht geklärt, wer hinter den Angriffen sitzt.\\

Welchen Schaden ein solcher Trojaner anrichten kann liegt auf der Hand. Die Summe aller allein durch Petya entstandenen Schäden beläuft sich auf ca. 1 Milliarde Euro. Allerdings variiert dieser Wert von Quelle zu Quelle stark. Daher ist anzunehmen, dass die Dunkelziffer weitaus höher ist. Fakt ist allerdings, dass die Geschichte und die Aktionen rund um Kryptotrojaner noch lange kein Ende finden und immer neuere und bessere entstehen werden. Daraufhin gelingt es Experten erneut, diese zu entschlüsseln und den Menschen somit Hilfen zu geben. Es bestehen schon für viele verschiedene Varianten Möglichkeiten, die Daten zu retten, jedoch nicht bei allen. In der heutigen Zeit werden zur Verbreitung große cloudgesteuerte Botnetze genutzt.\\


\section{Symmetrische Verschlüsselungsverfahren}
Symmetrische Verschlüsselungsverfahren bilden einen Großteil aller Verschlüsselungen. Diese Art ist die älteste Möglichkeit einen Text zu verschlüsseln. Die Caeser Chiffre bildet damit das wohl bekannteste Beispiel. Heute funktionieren die Algorithmen anders und sind sehr viel komplexer, was die Sicherheit extrem erhöht. Die bekanntesten Verschlüsselungen symmetrischer Art sind der IDEA, AES und DES
Die Grundidee ist, dass es exakt einen Schlüssel gibt. Es handelt sich dabei um einen privaten Key welcher geheim gehalten werden muss. Sobald der Schlüssel aus irgendeinem Grund veröffentlicht wird, verfällt die gesamte Sicherheit. Der Sender und der Empfänger haben den gleichen Schlüssel, womit der Text verschlüsselt und endschlüsselt wird. Bei verschiedenen Verfahren ist es möglich, dass Sender und Empfänger einen anderen Schlüssel haben, welcher jedoch relativ leicht auseinanderzurechnen ist und eine Ausnahme bildet. Ein weiterer Unterschied zu asymmetrischen Verschlüsselungen (RSA) ist, dass es sich um keine Einwegfunktion handelt. Das bedeutet, dass die Verschlüsselungsfunktion f umkehrbar ist. Folglich kehrt f* die Verschlüsselungsfunktion um. Voraussetzung ist natürlich, dass der gleiche Schlüssel k, der gleiche Geheimtext c und natürlich derselbe Klartext m. k steht für den geheimen Schlüssel (private Key).\cite{RSABuch}\\

Folglich gilt allgemein:
\begin{equation}
	c = f(k,m)
\end{equation}
Wie eingangs schon gesagt, muss aus denselben Parametern der Klartext wieder ermittelt werden. Dafür wird die Umkehrfunktion genutzt.\\

\begin{equation}
	m = f \cdot (k,c)
\end{equation}

Für eine erfolgreiche Verschlüsselung wird der Klartext in Blöcke mit gleicher Größe zerlegt (meist 64 Bit). Daraus kann man festlegen. Daraus ergibt sich demnach \\

\begin{equation}
	c = m_1 + m_2 + \cdots + m_i
\end{equation}


wobei $m_i$ das letzten Relevanten Block darstellt. Die Funktion f „nimmt“ also jeden Block und verschlüsselt ihn einzeln. Im Folgenden wird nun an einem Beispiel (dem AES) ein symmetrisches Verschlüsselungsverfahren erklärt. Vergleicht man die beiden Verschlüsselungen, so fällt auf, dass die asymmetrischen Verschlüsselungen allein auf mathematischen Grundlagen beruhen, was leider bei dem AES nicht der Fall ist. Dieser arbeitet komplexer und ist dadurch weitaus schwerer zu verstehen.
Das liegt im Grunde daran, dass AES nur einen privaten Schlüssel kennt.\\

Der Advanced Encryption Standard trägt den Namen nicht ohne Grund. Als Nachfolger des DES wurde er im Oktober 2000 veröffentlicht. Der DES hatte nur eine geringe Schlüssellänge, obwohl er mit weitaus längeren Schlüsseln umgehen kann.\\

Dadurch hat man mit einem Brute-Force-Angriff relative wenig Spaß. Der AES entstand nicht als Auftrag einer Organisation, sondern ging als Sieger aus einem Wettbewerb mit 19 verschiedenen Verschlüsselungen hervor. Alle anderen hatten Probleme in der Effizienz oder mit dem Algorithmus selbst. Der AES ist ein offenes System, was bedeutet, dass alle notwendigen Schritte in der Spezifikation zu finden sind.\\

Der AES arbeitet mit Hilfe von verschiedenen Runden, welche im Folgenden mit R bezeichnet werden. Zu allem Anfang muss erst die Länge des Schlüssels festgelegt werden. Selbsterklärend ist, dass mit zunehmender Schlüssellänge auch die Sicherheit zunimmt. Die normale Schlüssellänge liegt hier zwischen 128 und 256 Bit, also zwischen 16 und 32 Byte. Nun muss man das gewünschte Passwort eingeben und alles Weitere übernimmt nun der Computer. Meist kann der Nutzer nur das Kennwort wählen, da die Schlüssellänge bereits vorgegeben ist. Weiter wird aus dem Key je ein Schlüssel für eine Runde der Verschlüsselung gebildet. In den seltensten Fällen kann man die Anzahl der Runden angeben, welche sich jedoch meist zwischen zehn und dreizehn bewegen. Nun wird eine viermal vier große Matrix gebildet. Die Größe der Matrix resultiert aus der Länge des Schlüssels. Für jedes „Feld“ wird ein Byte des Schlüssels in Anspruch genommen. Das heißt, wenn der Schlüssel 8 Byte groß ist, wird auch eine Tabelle mit 8 Feldern benötigt, also eine 4x4 Matrix. In diese wird nun der Schlüssel geteilt und gelegt (pro Feld ein Byte). In einer anderen, aber gleich großen Tabelle, geschieht dasselbe, bloß mit dem zu verschlüsselten Block. Nun ersetzt der Algorithmus Runde für Runde jede Zelle der Matrix durch einen vorgegeben Wert. Aufgrund einer XOR-Addition mit der originalen Datei wird die „Datentabelle“ Bit für Bit variiert. Nun muss noch die Tabelle sortiert werden. Dies erfolgt, in dem jedes Element um einen vorher festgelegten Wert verschoben wird. Ähnlich der Caeser Scheibe. Nun läuft dieses System mehrere Runden hintereinander ab. Dadurch wird gewährleistet, dass der eigentliche Schlüssel nicht mehr wiederzuerkennen ist. Nur noch einer der beiden Partner kann nun rekursiv die Datei entschlüsseln und so an den „wahren“ Inhalt gelangen. Dieses Verfahren wird heute noch als sicher anerkannt und findet auch noch Anklang wo. Viele große Protokolle wie SSH und IPSec nutzen diese Art der Verschlüsselung. Auch in bekannten Programmen wie Skype findet es noch heute Beachtung. \cite{mathe1} \\

\section{Asymmetrische Verschlüsselung}
Die Asymmetrische Verschlüsselung ist ein wichtiger Teil der Kryptografie. Der Grundgedanke besteht darin, dass jeder Teilnehmer (also der Sender und der Empfänger) 2 Schlüssel hat, einen Privaten und einen Öffentlichen. Der private Schlüssel muss selbsterklärend geheim gehalten werden, wobei den öffentlichen Schlüssel jeder Mensch sehen oder besitzen kann. Allein mit Hilfe des öffentlichen Schlüssels ist es nicht möglich, eine Nachricht zu entschlüsseln, weshalb dieser auch einen sehr geringen Wert hat. Sollte allerdings ein Fremder den privaten Schlüssel in seinen Besitz bringen, ist das Verfahren gescheitert.   \\
Der Sender schreibt seine Nachricht und verschlüsselt sie mit dem öffentlichen Schlüssel des Empfängers. Nun kann nur noch dieser die Nachricht entschlüsseln. Dafür nutzt er jedoch nicht seinen öffentlichen (so wie der Sender bei der Verschlüsselung), sondern seinen privaten Schlüssel. So wird gewährleistet, dass keine dritte Person die Nachricht des Klartextes lesen kann. Theoretisch ist es sogar möglich, den verschlüsselten Text ebenfalls zu veröffentlichen. Dies ist zwar möglich, allerdings der Sicherheit nicht wirklich fördernd, sondern eher hemmend.\\

Der große Vorteil der asymmetrischen Verschlüsselung ist, dass jeder eine verschlüsselte Nachricht erstellen, aber nur der Empfänger sie entschlüsseln kann. Ein großer Nachteil besteht allerdings darin, dass der Empfänger sich nicht absolut sicher sein kann, dass die Nachricht von dem Sender kommt. Die Ursache ist, dass jedermann eine Nachricht erstellen kann. Um dieses Problem zu lösen, muss eine Authentifikation erfolgen, welche über unterschiedliche Wege erfolgen kann. In der analogen Welt geschieht dies meist durch eine Unterschrift. Es wäre allerdings auch vorstellbar, sich durch andere Möglichkeiten zu authentifizieren. Dafür genügt meist schon ein Tropfen Blut oder ein Fingerabdruck, da dieser bei jedem Menschen verschieden ist. Im Laufe der Zeit hat sich ein asymmetrisches Verschlüsselungsverfahren durchgesetzt, das RSA. Dieses Verfahren wird heute noch als sicher anerkannt. Der RSA wurde 1977 entwickelt und auf der ACM 21 im Jahre 1987 vorgestellt. Der Algorithmus ist bis heute sicher und kann in naher Zukunft auch nicht geknackt werden. Der Name „RSA“ setzt sich aus den Anfangsbuchstaben der Entwickler zusammen (Ronald L. Rivest, Adi Shamir und Leonard Adleman). Das Verfahren nutzt das Modulo als mathematische Funktion. Dieser gibt den ganzzahligen Rest einer Division zurück. So würde 10 mod 5 = 0 ergeben, da $\frac{10}{5} = 2$ ist und somit kein Rest entsteht. Allerdings ist 3 modo 2 nicht.0, da 32 nicht 0 ist. Hier ist leicht zu erkennen, dass nur eine Zahl hinter dem Komma steht. Folglich ist mod (3,2) = 1. Leider lässt sich diese mathematische Funktion nicht ohne weiteres umsetzten. Deshalb wurde für die hier vorliegende Berechnung eine etwas andere Funktion genutzt. Auf diese werden wir im späteren Verlauf der Arbeit eingehen. \\

Eine weitere mathematische Funktion, die bei dem RSA genutzt wird, ist der größte gemeinsamere Teiler (kurz ggT). Zuerst zerlegt man die zu vergleichenden Zahlen in ihre Teiler. Hier kurz ein Beispiel mit 14 und 24. Die Teiler von 14 sind 1,2,7,14. Die Teiler von 24 sind 1,2,3,4,6,8,12,24. Folglich ist das ggT der beiden Zahlen 2.
Der RSA ist ein Einweg Algorithmus. Das heißt, er funktioniert nur in eine Richtung. Es ist leicht mit ihm zu verschlüsseln. Allerdings ist es ist es ohne privaten Schlüssel fast unmöglich einen verschlüsselten Text zu dechiffrieren. In der Praxis werden sehr große Primzahlen genutzt, um die Sicherheit zu gewährleisten. Je größer die Primzahlen sind, desto höher wird die Sicherheit. Das bedeutet, dass die Primzahlen exponentiell zu dem technischen Fortschritt wachsen müssen. Auch dieses „Problem“ wird an anderer Stelle der Arbeit behandelt.\\
Da in diesem Abschnitt der Algorithmus im Vordergrund steht, werden nun nur Primzahlen im Zahlenbereich bis 10 genutzt.
Um eine Nachricht mit RSA zu verschlüsseln, werden 5 Schritte benötigt.\\
Im ersten Schritt wählt der Sender zwei Primzahlen. Diese (p und q) müssen sich unterscheiden und dürfen nicht gleich sein. Für ein Beispiel wählen wir\\	
\begin{equation}
	p=17 \textmd{~ und ~}q=11
\end{equation}

Weiter brauchen wir eine Zahl e, die folgende Bedingung erfüllt. Dabei darf e keine Primzahl sein. \\
\begin{equation}
	1 = ggT(e,((p-1) \cdot (q-1)))
\end{equation}

So kann überprüft werden, ob e und $((p-1)\cdot (q-1))$ teilerfremd sind. In unserem Beispiel haben wir.
\begin{equation}
	e=7
\end{equation}

gewählt. Den privaten Schlüssel des Empfängers "d" berechnet man wie folgt.
\begin{equation}
	1 = (e \cdot d)\textmd{~mod~}((p-1)\cdot(q-1))
\end{equation}

Unter Zuhilfenahme einer leicht modifizierten Variante ist der private Schlüssel.\\
\begin{equation}
	1 = (7 \cdot d) \textmd{~mod~}160 \rightarrow d=23
\end{equation}

Da der private Schlüssel der Dreh und Angelpunkt der Verschlüsselung ist, muss er überprüft werden.\\

\begin{equation}
	1 = 161 \textmd{~mod~} 160
\end{equation}
Im zweiten Schritt muss der öffentliche Schlüssel erzeugt werden. Dieser kann wie schon eingangs gesagt, veröffentlicht werden. Der public Key trägt das „Kürzel“ N.
\begin{equation}
	N = p \cdot q = 187
\end{equation}
e wird aus dem ersten Schritt mitgeführt. Im dritten Schritt muss nun der zu verschlüsselnde Text (hier der Buchstabe „A“) in Zahlen umgewandelt werden. Hierfür empfiehlt sich ein Blick in die ASCII-Tabelle. M ist hierbei der Klartext.
\begin{equation}
	M = 65  \textmd{~ | ~A}
\end{equation}
Im vierten Schritt muss nun M verschlüsselt werden. Dafür nutzt man folgende Formel.
\begin{align}
	C &= M^e \textmd{~mod~} N\\
	&= 65^7 \textmd{~mod~} 187\\
	& = 142
\end{align}
So ist der Empfänger in der Lage, die Nachricht wieder zu entschlüsseln und an den unverschlüsselten Text zu gelangen. \cite{facharbeit} \\	
Die Ausarbeitungen für die asymmetrische Verschlüsselung werden im Kapitel, „Ziele der Kryptologie und Tauglichkeitsuntersuchung„ angewendet und näher auf die RSA Verschlüsselung, in Bezug auf Tauglichkeit und Sicherheit, erläutert. \\

	